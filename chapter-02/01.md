---
title: Ready for Picking
inprog: true
---

# {{ page.title }}

{% excercise name="Foo" %}
Foo
{% endexcercise %}

## In general

  - start off light on theory
    - show why something is useful
    - dive into theory afterwards
    - repeat what was learned before theory
  - start having all functions in a single file
  - we'll revisit this decision later
  - everything in `src/index.js`
  - always use function expressions

---

Remember to export the functions you're assigned to implement.

## Arrays, the Alpha and the Omega

More often than not, a lot of the data handled in programming is somehow related to arrays, or in generic terms, _collections_. The string `foobar` is an array that consists of the characters that make up the word (`'foobar'[2] === 'o'`). A shopping cart is a collection of products. The Twitter timeline is a collection of tweets. The HTML for this page is a collection of elements, contained in a collection of elements. So maybe it should be _arrays all the way down_?

In this chapter we'll only cover arrays and dive into functionality for objects later on.

### Taking a little bit first

Let's create some basic functions for taking an element or multiple elements from an array. Don't be concerned on safety at this point, e.g. what if you give your functions an invalid argument.

Create the following exported functions:

#### `length :: [a] ~> Number`

Create an exported function called `length` that takes an array of `x` and returns the length of the array.

#### `isEmpty :: [a] ~> Boolean`

Create an exported function called `isEmpty` that receives an array and returns a boolean value if the list is empty.

```js
isEmpty([1, 2, 3]) === false

       isEmpty([]) === true
```

#### `head :: [a] ~> a`

Create an exported function called `head` that receives an array takes an array and returns the first element from that list.

```js
head([1, 2, 3]) === 1

       head([]) === undefined
```

#### `last :: [a] ~> a`

Create an exported function called `last` that works identical to `head`, but instead returns the last element.

#### `init :: [a] ~> [a]`

Create an exported function called `init` that takes an array and returns a new list of all elements but the last.

#### `tail :: [a] ~> [a]`

Create an exported function called `tail` which is identical to `init` above, but instead returns all elements but the first.

#### `cons :: (a, [a]) ~> [a]`

Create an exported function called `cons` which takes an element and an array of elements, and returns an array which contains the first argument as the first element, and the array in the second argument as the list's tail.

In other words, the result of applying `cons` is equal to putting the `head` and `tail` together.

{% math %}
\begin{aligned}
cons(head(\texttt{xs}), tail(\texttt{xs})) &= \texttt{xs} \\[2ex]
cons(\texttt{1, }[\texttt{2, 3, 4, 5}]) &= \texttt{1, 2, 3, 4, 5}
\end{aligned}
{% endmath %}

#### `uncons :: [a] ~> [a, [a]]`

Create an exported function called `uncons` which is the inverse of `cons` above. That is, the function takes an array as its argument, and returns the array decomposed into an array containing the head and tail of the list.

In other words:

{% math %}
\begin{aligned}
uncons(\texttt{xs}) &= [head(\texttt{xs}), tail(\texttt{xs})] \\[2ex]
uncons([\texttt{1, 2, 3, 4, 5}]) &= [\texttt{1, }[\texttt{2, 3, 4, 5}]]
\end{aligned}
{% endmath %}

```js
uncons([1, 2, 3, 4, 5]) ~> [1, [2, 3, 4, 5]]
```

---

### Why

You may have a number of questions concerning _why are we creating a function that returns the length of the list_, for example, and that is an entirely valid question. I don't really have a concise answer to this other than that it helps you when you are composing functions together—and if you don't understand what I just said, don't worry about it, we'll look into it in due time.

Although `cons` and `uncons` may be of limited use, those two functions are good examples when considering how you can end up at the same result through multiple different ways. There is no single and correct way how things like lists are put together, as the problem you're facing will differ from time to time.

For this reason being able to construct the same kind of data structure in a number of different ways can extend your perspective when working with real-world data. You may have an idea of what an _ideal_ structure for data would be—be it for a blog, Twitter feed, or even a weather service or just something that counts how many times you've clicked on a button—but in the end, what data you _actually_ get can be an entirely different story. Reality is far from ideal.

For this reason being able to end up with the same result different functions from time to time will make you more aware of possible solutions to a problem you're tackling.

{% include "../_templates/attention.md" %}

Going back to `cons` and `uncons`, the two are actually much more important than meets the eye; with them you can create and to some degree manipulate [singly linked lists](https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list). Singly linked lists are the precursor to most of other data structures we have today, but they aren't important at this point. It's good to be aware to at least some degree how some data structure works; you don't have to know it inside out, but it's great help to think about how is the thing _x_ implemented in your language. You never know what you'll find or how it might help you, but it's not wasted effort at least!

But as you can see, we can arrive at the same result by doing different things. `uncons` decomposes your list into the _head_ and the _tail_ of the list. Maybe we should have a `snocnu`—that is, `uncons` backwards—function that would decompose a list into its _last_ and _init_?
